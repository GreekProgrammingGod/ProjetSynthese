{\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang12 /*\par
   +----------------------------------------------------------------------+\par
   | HipHop for PHP                                                       |\par
   +----------------------------------------------------------------------+\par
   | Copyright (c) 2010-2014 Facebook, Inc. ({{\field{\*\fldinst{HYPERLINK http://www.facebook.com }}{\fldrslt{http://www.facebook.com\ul0\cf0}}}}\f0\fs22 )     |\par
   | Copyright (c) 1997-2010 The PHP Group                                |\par
   +----------------------------------------------------------------------+\par
   | This source file is subject to version 3.01 of the PHP license,      |\par
   | that is bundled with this package in the file LICENSE, and is        |\par
   | available through the world-wide-web at the following url:           |\par
   | {{\field{\*\fldinst{HYPERLINK http://www.php.net/license/3_01.txt }}{\fldrslt{http://www.php.net/license/3_01.txt\ul0\cf0}}}}\f0\fs22                                   |\par
   | If you did not receive a copy of the PHP license and are unable to   |\par
   | obtain it through the world-wide-web, please send a note to          |\par
   | license@php.net so we can mail you a copy immediately.               |\par
   +----------------------------------------------------------------------+\par
*/\par
\par
#include "hphp/runtime/ext/ext_math.h"\par
#include "hphp/runtime/base/zend-math.h"\par
#include "hphp/runtime/base/zend-multiply.h"\par
#include "hphp/runtime/base/container-functions.h"\par
#include "hphp/system/constants.h"\par
\par
namespace HPHP \{\par
///////////////////////////////////////////////////////////////////////////////\par
\par
const int64_t k_PHP_ROUND_HALF_UP =   PHP_ROUND_HALF_UP;\par
const int64_t k_PHP_ROUND_HALF_DOWN = PHP_ROUND_HALF_DOWN;\par
const int64_t k_PHP_ROUND_HALF_EVEN = PHP_ROUND_HALF_EVEN;\par
const int64_t k_PHP_ROUND_HALF_ODD =  PHP_ROUND_HALF_ODD;\par
\par
double f_pi() \{ return k_M_PI;\}\par
\par
Variant f_min(int _argc, const Variant& value, const Array& _argv /* = null_array */) \{\par
  if (_argv.empty()) \{\par
    const auto& cell_value = *value.asCell();\par
    if (UNLIKELY(!isContainer(cell_value))) \{\par
      return value;\par
    \}\par
\par
    ArrayIter iter(cell_value);\par
    if (!iter) \{\par
      return uninit_null();\par
    \}\par
    Variant ret = iter.secondRefPlus();\par
    ++iter;\par
    for (; iter; ++iter) \{\par
      Variant currVal = iter.secondRefPlus();\par
      if (less(currVal, ret)) \{\par
        ret = currVal;\par
      \}\par
    \}\par
    return ret;\par
  \}\par
\par
  Variant ret = value;\par
  for (ArrayIter iter(_argv); iter; ++iter) \{\par
    Variant currVal = iter.secondRef();\par
    if (less(currVal, ret)) \{\par
      ret = currVal;\par
    \}\par
  \}\par
  return ret;\par
\}\par
\par
Variant f_max(int _argc, const Variant& value, const Array& _argv /* = null_array */) \{\par
  if (_argv.empty()) \{\par
    const auto& cell_value = *value.asCell();\par
    if (UNLIKELY(!isContainer(cell_value))) \{\par
      return value;\par
    \}\par
\par
    ArrayIter iter(cell_value);\par
    if (!iter) \{\par
      return uninit_null();\par
    \}\par
    Variant ret = iter.secondRefPlus();\par
    ++iter;\par
    for (; iter; ++iter) \{\par
      Variant currVal = iter.secondRefPlus();\par
      if (more(currVal, ret)) \{\par
        ret = currVal;\par
      \}\par
    \}\par
    return ret;\par
  \}\par
\par
  Variant ret = value;\par
  for (ArrayIter iter(_argv); iter; ++iter) \{\par
    Variant currVal = iter.secondRef();\par
    if (more(currVal, ret)) \{\par
      ret = currVal;\par
    \}\par
  \}\par
  return ret;\par
\}\par
\par
/* Logic based on zend_operators.c::convert_scalar_to_number() */\par
static DataType zend_convert_scalar_to_number(const Variant& num,\par
                                              int64_t &ival,\par
                                              double &dval) \{\par
  DataType dt = num.toNumeric(ival, dval, true);\par
  if ((dt == KindOfDouble) || (dt == KindOfInt64)) \{\par
    return dt;\par
  \}\par
\par
  if (num.isBoolean() || num.isNull() || num.isObject() || num.isResource() ||\par
      num.isString()) \{\par
    ival = num.toInt64();\par
    return KindOfInt64;\par
  \}\par
\par
  // Fallback, callers will handle this as an error\par
  ival = 0;\par
  dval = 0.0;\par
  return num.getType();\par
\}\par
\par
Variant f_abs(const Variant& number) \{\par
  int64_t ival;\par
  double dval;\par
  DataType k = zend_convert_scalar_to_number(number, ival, dval);\par
  if (k == KindOfDouble) \{\par
    return fabs(dval);\par
  \} else if (k == KindOfInt64) \{\par
    return ival >= 0 ? ival : -ival;\par
  \} else \{\par
    return false;\par
  \}\par
\}\par
\par
bool f_is_finite(double val) \{ return finite(val);\}\par
bool f_is_infinite(double val) \{ return isinf(val);\}\par
bool f_is_nan(double val) \{ return isnan(val);\}\par
\par
Variant f_ceil(const Variant& number) \{\par
  int64_t ival;\par
  double dval;\par
  DataType k = zend_convert_scalar_to_number(number, ival, dval);\par
  if (k == KindOfInt64) \{\par
    dval = (double)ival;\par
  \} else if (k != KindOfDouble) \{\par
    return false;\par
  \}\par
  return ceil(dval);\par
\}\par
\par
Variant f_floor(const Variant& number) \{\par
  int64_t ival;\par
  double dval;\par
  DataType k = zend_convert_scalar_to_number(number, ival, dval);\par
  if (k == KindOfInt64) \{\par
    dval = (double)ival;\par
  \} else if (k != KindOfDouble) \{\par
    return false;\par
  \}\par
  return floor(dval);\par
\}\par
\par
Variant f_round(const Variant& val, int64_t precision /* = 0 */,\par
                int64_t mode /* = PHP_ROUND_HALF_UP */) \{\par
  int64_t ival;\par
  double dval;\par
  DataType k = zend_convert_scalar_to_number(val, ival, dval);\par
  if (k == KindOfInt64) \{\par
    if (precision >= 0) \{\par
     return (double)ival;\par
    \} else \{\par
      dval = ival;\par
    \}\par
  \} else if (k != KindOfDouble) \{\par
    return false;\par
  \}\par
  dval = php_math_round(dval, precision, mode);\par
  return dval;\par
\}\par
\par
double f_deg2rad(double number) \{ return number / 180.0 * k_M_PI;\}\par
double f_rad2deg(double number) \{ return number / k_M_PI * 180.0;\}\par
\par
String f_decbin(int64_t number) \{\par
  return String(string_long_to_base(number, 2), AttachString);\par
\}\par
String f_dechex(int64_t number) \{\par
  return String(string_long_to_base(number, 16), AttachString);\par
\}\par
String f_decoct(int64_t number) \{\par
  return String(string_long_to_base(number, 8), AttachString);\par
\}\par
Variant f_bindec(const String& binary_string) \{\par
  return string_base_to_numeric(binary_string.data(), binary_string.size(), 2);\par
\}\par
Variant f_hexdec(const String& hex_string) \{\par
  return string_base_to_numeric(hex_string.data(), hex_string.size(), 16);\par
\}\par
Variant f_octdec(const String& octal_string) \{\par
  return string_base_to_numeric(octal_string.data(), octal_string.size(), 8);\par
\}\par
\par
Variant f_base_convert(const String& number, int64_t frombase, int64_t tobase) \{\par
  if (!string_validate_base(frombase)) \{\par
    throw_invalid_argument("Invalid frombase: %" PRId64, frombase);\par
    return false;\par
  \}\par
  if (!string_validate_base(tobase)) \{\par
    throw_invalid_argument("Invalid tobase: %" PRId64, tobase);\par
    return false;\par
  \}\par
  Variant v = string_base_to_numeric(number.data(), number.size(), frombase);\par
  return String(string_numeric_to_base(v, tobase), AttachString);\par
\}\par
\par
Variant f_pow(const Variant& base, const Variant& exp) \{\par
  int64_t bint, eint;\par
  double bdbl, edbl;\par
  DataType bt = base.toNumeric(bint, bdbl, true);\par
  DataType et = exp.toNumeric(eint, edbl, true);\par
  if (bt == KindOfInt64 && et == KindOfInt64 && eint >= 0) \{\par
    if (eint == 0) return 1LL;\par
    if (bint == 0) return 0LL;\par
\par
    // calculate pow(long,long) in O(log exp) operations, bail if overflow\par
    int64_t l1 = 1;\par
    while (eint >= 1) \{\par
      int overflow;\par
      double dval = 0.0;\par
      if (eint % 2) \{\par
        --eint;\par
        ZEND_SIGNED_MULTIPLY_LONG(l1, bint, l1, dval, overflow);\par
        if (overflow) return dval * pow(bint, eint);\par
      \} else \{\par
        eint /= 2;\par
        ZEND_SIGNED_MULTIPLY_LONG(bint, bint, bint, dval, overflow);\par
        if (overflow) return (double)l1 * pow(dval, eint);\par
      \}\par
      if (eint == 0) \{\par
        return l1;\par
      \}\par
    \}\par
  \}\par
  if (bt != KindOfDouble) \{\par
    bdbl = base.toDouble();\par
  \}\par
  if (et != KindOfDouble) \{\par
    edbl = exp.toDouble();\par
  \}\par
  return pow(bdbl, edbl);\par
\}\par
\par
double f_exp(double arg) \{ return exp(arg);\}\par
double f_expm1(double arg) \{ return expm1(arg);\}\par
double f_log10(double arg) \{ return log10(arg);\}\par
double f_log1p(double number) \{ return log1p(number);\}\par
double f_log(double arg, double base /* = 0 */) \{\par
  return base <= 0 ? log(arg) : log(arg)/log(base);\par
\}\par
\par
double f_cos(double arg) \{ return cos(arg);  \}\par
double f_cosh(double arg) \{ return cosh(arg); \}\par
double f_sin(double arg) \{ return sin(arg);  \}\par
double f_sinh(double arg) \{ return sinh(arg); \}\par
double f_tan(double arg) \{ return tan(arg);  \}\par
double f_tanh(double arg) \{ return tanh(arg); \}\par
double f_acos(double arg) \{ return acos(arg); \}\par
double f_acosh(double arg) \{ return acosh(arg);\}\par
double f_asin(double arg) \{ return asin(arg); \}\par
double f_asinh(double arg) \{ return asinh(arg);\}\par
double f_atan(double arg) \{ return atan(arg); \}\par
double f_atanh(double arg) \{ return atanh(arg);\}\par
double f_atan2(double y, double x) \{ return atan2(y, x);\}\par
\par
double f_hypot(double x, double y) \{ return hypot(x, y);\}\par
double f_fmod(double x, double y) \{ return fmod(x, y);\}\par
double f_sqrt(double arg) \{ return sqrt(arg);\}\par
\par
int64_t f_getrandmax() \{ return RAND_MAX;\}\par
\par
///////////////////////////////////////////////////////////////////////////////\par
\par
static bool s_rand_is_seeded = false;\par
\par
void f_srand(const Variant& seed /* = null_variant */) \{\par
  s_rand_is_seeded = true;\par
  if (seed.isNull()) \{\par
    return srand(math_generate_seed());\par
  \}\par
  if (seed.isNumeric(true)) \{\par
    srand(seed.toInt32());\par
  \} else \{\par
    raise_warning("srand() expects parameter 1 to be long");\par
  \}\par
\}\par
\par
int64_t f_rand(int64_t min /* = 0 */, int64_t max /* = RAND_MAX */) \{\par
  if (!s_rand_is_seeded) \{\par
    s_rand_is_seeded = true;\par
    srand(math_generate_seed());\par
  \}\par
\par
  int64_t number = rand();\par
  if (min != 0 || max != RAND_MAX) \{\par
    RAND_RANGE(number, min, max, RAND_MAX);\par
  \}\par
  return number;\par
\}\par
\par
int64_t f_mt_getrandmax() \{ return MT_RAND_MAX;\}\par
\par
void f_mt_srand(const Variant& seed /* = null_variant */) \{\par
  if (seed.isNull()) \{\par
    return math_mt_srand(math_generate_seed());\par
  \}\par
  if (seed.isNumeric(true)) \{\par
    math_mt_srand(seed.toInt32());\par
  \} else \{\par
    raise_warning("mt_srand() expects parameter 1 to be long");\par
  \}\par
\}\par
\par
int64_t f_mt_rand(int64_t min /* = 0 */, int64_t max /* = RAND_MAX */) \{\par
  return math_mt_rand(min, max);\par
\}\par
double f_lcg_value() \{ return math_combined_lcg();\}\par
\par
///////////////////////////////////////////////////////////////////////////////\par
\}\par
}
 